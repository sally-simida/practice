<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
    <script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
    <style>
      .tetris-wrapper {
        position: absolute;
        top: 0;
        bottom: 0;
        left: 0;
        right: 0;
        background: #fff;
      }
      .game-wrapper {
        position: absolute;
        top: 0.1rem;
        bottom: 0.1rem;
        left: 0.1rem;
        right: 0.1rem;
        display: flex;
        flex-direction: column;
        background: url('./img/ground.jpg');
      }
      .block-group {
        flex: 1;
        position: relative;
        display: flex;
      }
      .block {
        flex: 1;
      }
      .body {
        background-color: rgb(43, 42, 42);
        border-radius: 1rem;
      }
      .head {
        background: url("img/header.png");
        background-size: 100%;
      }
      .tail {
        background-color: rgb(26, 26, 26);
        border-radius: 1rem;
      }
      .food {
        background: url('./img/ham.png');
        background-size: 120%;
      }
      .count{
          position: absolute;
          z-index: 1;
          color: wheat;
          left: 50%;
          margin-left: -80px;
          font-size: 30px;
      }
    </style>
  </head>
  <body>
      <div
      id="game"
      class="tetris-wrapper"
      @click="test"
      ref="test"
      @swipeup="changeMoveDirection(0)"
      @swiperight="changeMoveDirection(1)"
      @swipedown="changeMoveDirection(2)"
      @swipeleft="changeMoveDirection(3)"
      >
      <div class="count">* ç´¯è®¡å¾—åˆ†ï¼š<span v-html="number"></span> *</div>
      <div class="game-wrapper" ref="container">
        <div
          class="block-group"
          v-for="(item, index) in structureArray"
          :key="index"
        >
          <div
            class="block"
            v-for="(block, blockIndex) in item"
            :key="blockIndex"
            :class="{body: block.state === 1, head: block.state === 2, tail: block.state === 3, food: block.state === 4}"
          ></div>
        </div>
      </div>
    </div>
    <script>
      let app = new Vue({
        el: "#game",
        data() {
          return {
            timer: null, // å­˜å‚¨å®šæ—¶å™¨
            interval: 400, // å®šæ—¶é—´éš”æ—¶é—´
            transverse: 40, // æ¨ªåæ ‡æ–¹æ ¼æ•°é‡
            structureArray: [], // æ¸¸æˆç”»å¸ƒç»“æ„æ•°ç»„
            moveDirection: 1, // è›‡çš„ç§»åŠ¨æ–¹å‘ï¼Œ0ã€1ã€2ã€3ï¼Œä¸Šå³ä¸‹å·¦
            nextMoveDirection: 1, // å°†è¦ç§»åŠ¨çš„æ–¹å‘ï¼Œ0ã€1ã€2ã€3ï¼Œä¸Šå³ä¸‹å·¦
            snakeHead: {}, // è›‡å¤´çš„åæ ‡
            snakeTail: {}, // è›‡å°¾åæ ‡
            foodCoordinate: {}, // é£Ÿç‰©åæ ‡
            number:0
          };
        },
        methods: {
          test() {
            console.log(this.$refs.container.clientHeight);
            console.log(this.$refs.container.clientWidth);
            console.log(this.longitudinal);
          },
          changeMoveDirection(direction) {
            // æ”¹å˜è›‡çš„è¿åŠ¨æ–¹å‘
            let judge = direction - this.moveDirection; // åˆ¤æ–­éæ³•çš„è›‡å¤´è½¬å‘
            if (judge === 2 || judge === -2) return;
            this.nextMoveDirection = direction;
          },
          mobileRule() {
            // è›‡çš„ç§»åŠ¨è§„åˆ™å®šä¹‰
            let { x, y } = this.snakeHead; // å½“å‰è›‡å¤´çš„åæ ‡
            let headCode = this.structureArray[y][x].code; // è·å–å½“å‰è›‡å¤´çš„code,ç”¨æ¥ç”Ÿæˆæ–°è›‡å¤´æ—¶++ä½¿ç”¨
            this.structureArray[y][x].state = 1; // å–æ¶ˆåŸæ¥çš„è›‡å¤´çŠ¶æ€
            switch (
              this.nextMoveDirection // ç§»åŠ¨æ–¹å‘ï¼Œè®¡ç®—ç§»åŠ¨åçš„æ¨ªçºµåæ ‡
            ) {
              case 0:
                y--;
                break;
              case 1:
                x++;
                break;
              case 2:
                y++;
                break;
              case 3:
                x--;
                break;
              default:
                throw new Error("è›‡çš„ç§»åŠ¨è§„åˆ™åˆ¤æ–­å‡ºé”™");
                break;
            }
            this.structureArray[y].splice(x, 1, { state: 2, code: ++headCode }); // ç”Ÿæˆæ–°çš„è›‡å¤´
            this.snakeHead = { x, y };
            this.moveDirection = this.nextMoveDirection;
            this.whetherEatFood(); // åˆ¤æ–­æ˜¯å¦åƒåˆ°é£Ÿç‰©ï¼ˆè›‡å¤´å’Œé£Ÿç‰©åæ ‡æ˜¯å¦é‡åˆï¼‰
          },
          whetherEatFood() {
            // æ˜¯å¦åƒåˆ°é£Ÿç‰©åˆ¤æ–­
            let state =
              JSON.stringify(this.snakeHead) ===
              JSON.stringify(this.foodCoordinate); // åˆ¤æ–­é£Ÿç‰©å’Œè›‡å¤´æ˜¯å¦åœ¨ä¸€ä¸ªåæ ‡ä¸Š
            if (state) {
              // åƒåˆ°äº†
              this.generateFood(); // ç”Ÿæˆé£Ÿç‰©
              this.integralRule(); // èµ°ç§¯åˆ†
              this.increaseDifficulty(); // å¢åŠ éš¾åº¦
              this.count++
            } else {
              // æ²¡åƒåˆ°é£Ÿç‰©
              this.generateSnakeTail(); // é‡æ–°ç”Ÿæˆè›‡å°¾
            }
          },
          generateFood() {
            // ç”Ÿæˆé£Ÿç‰©,ç”Ÿæˆéšæœºé£Ÿç‰©åæ ‡
            let x = Math.floor(Math.random() * this.transverse); // ç”Ÿæˆéšæœºæ•°
            let y = Math.floor(Math.random() * this.longitudinal); // ç”Ÿæˆéšæœºæ•°
            if (this.structureArray[y][x].state === 0) {
              // æ˜¯ç©ºä½ç½®
              this.foodCoordinate = { x, y }; // æ–°çš„é£Ÿç‰©åæ ‡
              this.structureArray[y].splice(x, 1, { state: 4, code: Infinity }); // ä¿®æ”¹åæ ‡çŠ¶æ€å€¼,codeæ— é™å¤§ç”¨æ¥è®¡ç®—è›‡å°¾æ—¶ä¸ä¼šå‡ºé”™
            } else {
              // ä½ç½®ä¸ä¸ºç©ºï¼Œé‡æ–°ç”Ÿæˆ
              this.generateFood();
            }
          },
          integralRule() {
            // ç§¯åˆ†è§„åˆ™
            this.number++;
            if(this.number % 10 == 0){
                this.number = this.number + 5
            }
          },
          increaseDifficulty() {
            // å¢åŠ éš¾åº¦è§„åˆ™
            if (this.interval <= 100) return;
            this.interval -= 10;
            this.clearTimer();
            this.initializationTimer();
          },
          generateSnakeTail() {
            // é‡æ–°ç”Ÿæˆè›‡å°¾(åœ¨æ²¡æœ‰åƒåˆ°é£Ÿç‰©çš„æƒ…å†µä¸‹è°ƒç”¨)
            let { x, y } = this.snakeTail; // è·å–è›‡å°¾åæ ‡
            // let tailCode = this.structureArray[y][x].code + 1; // è®¡ç®—å°†è¦ä½œä¸ºè›‡å°¾çš„code -------- è¿™é‡Œcodeå–é”™äº†ï¼Œè¿™æ ·çš„è¯å–å¾—æ˜¯è›‡å¤´çš„ï¼Œæ”¹æˆå–ä¸Šä¸‹å·¦å³æœ€å°çš„code
            // é”€æ¯ä¹‹å‰çš„è›‡å°¾(è‹¥å½“å‰è›‡å°¾è›‡å°¾ä½ç½®æ˜¯è›‡å¤´ï¼Œåˆ™ä¸åšå¤„ç†ï¼Œå› ä¸ºå¤´å…ˆç”Ÿæˆ)
            if (this.structureArray[y][x].state !== 2)
              this.structureArray[y].splice(x, 1, { state: 0 });
            // æ¥ä¸‹æ¥é‡æ–°å®šä½è›‡å°¾åæ ‡
            /*if (this.structureArray[y + 1][x].state && tailCode === this.structureArray[y + 1][x].code) y++;
        else if (this.structureArray[y - 1][x].state && tailCode === this.structureArray[y - 1][x].code) y--;
        else if (this.structureArray[y][x + 1].state && tailCode === this.structureArray[y][x + 1].code) x++;
        else if (this.structureArray[y][x - 1].state && tailCode === this.structureArray[y][x - 1].code) x--;*/
            // else throw new Error('é‡æ–°ç”Ÿæˆè›‡å°¾é”™è¯¯')
            // å–ä¸Šä¸‹å·¦å³codeæœ€å°çš„æ˜¯æ–°è›‡å°¾
            let top =
              y - 1 >= 0 && this.structureArray[y - 1][x].state ? this.structureArray[y - 1][x].code : Infinity;
            let bottom =
              y + 1 < this.longitudinal && this.structureArray[y + 1][x].state
                ? this.structureArray[y + 1][x].code
                : Infinity;
            let left =
              x - 1 >= 0 && this.structureArray[y][x - 1].state
                ? this.structureArray[y][x - 1].code
                : Infinity;
            let right =
              x + 1 < this.transverse && this.structureArray[y][x + 1].state
                ? this.structureArray[y][x + 1].code
                : Infinity;
            let min = Math.min(top, bottom, left, right);
            switch (min) {
              case top:
                y--;
                break;
              case bottom:
                y++;
                break;
              case left:
                x--;
                break;
              case right:
                x++;
                break;
              default:
                console.log("é‡æ–°ç”Ÿæˆè›‡å°¾å‡ºé”™äº†");
                break;
            }
            this.snakeTail = { x, y }; // ä¿å­˜è›‡å°¾åæ ‡
            this.structureArray[y][x].state = 3; // å°†æ­¤åæ ‡å®šä¹‰ä¸ºè›‡å°¾
          },
          deathRule() {
            // è›‡çš„æ­»äº¡è§„åˆ™åˆ¤æ–­
            let { x, y } = this.snakeHead;
            switch (
              this.nextMoveDirection // ç§»åŠ¨æ–¹å‘(ç¢°å£åˆ¤æ–­å’Œç¢°è›‡èº«åˆ¤æ–­)
            ) {
              case 0:
                if (y - 1 < 0) return false;
                else if (this.structureArray[y - 1][x].state === 1)
                  return false;
                break;
              case 1:
                if (x + 1 > this.transverse - 1) return false;
                else if (this.structureArray[y][x + 1].state === 1)
                  return false;
                break;
              case 2:
                if (y + 1 > this.longitudinal - 1) return false;
                else if (this.structureArray[y + 1][x].state === 1)
                  return false;
                break;
              case 3:
                if (x - 1 < 0) return false;
                else if (this.structureArray[y][x - 1].state === 1)
                  return false;
                break;
              default:
                throw new Error("è›‡çš„æ­»äº¡è§„åˆ™åˆ¤æ–­é”™è¯¯");
                break;
            }
            return true;
          },
          deathTreatment() {
            // è›‡çš„æ­»äº¡å¤„ç†
            this.clearTimer();
            alert("å‘†ç“œ~è¾“äº†å§ï¼å“ˆå“ˆå“ˆğŸ˜„");
          },
          initializationGrid() {
            // åˆå§‹åŒ–ç½‘æ ¼
            this.structureArray = [];
            for (let i = 0; i < this.longitudinal; i++) {
              this.structureArray.push([]);
              for (let j = 0; j < this.transverse; j++) {
                this.structureArray[i].push({
                  state: 0, // 0ä¸ºç©ºï¼Œ1ä¸ºè›‡èº«ï¼Œ2ä¸ºè›‡å¤´ï¼Œ3ä¸ºè›‡å°¾ï¼Œ4ä¸ºé£Ÿç‰©
                });
              }
            }
          },
          initializationSnake() {
            // åˆå§‹åŒ–è›‡
            this.structureArray[2].splice(4, 1, { state: 2, code: 2 });
            this.structureArray[2].splice(3, 1, { state: 1, code: 1 });
            this.structureArray[2].splice(2, 1, { state: 3, code: 0 });
            this.snakeHead = { x: 4, y: 2 }; // è›‡å¤´åæ ‡
            this.snakeTail = { x: 2, y: 2 }; // è›‡å°¾åæ ‡
          },
          initializationTimer() {
            // åˆå§‹åŒ–å®šæ—¶å™¨
            this.timer = setInterval(() => {
              // å¤„ç†
              if (this.deathRule()) {
                // æ­»ä¸äº†
                this.mobileRule(); // èµ°ç§»åŠ¨
              } else {
                // æ­»æ‰äº†
                this.deathTreatment();
              }
            }, this.interval);
          },
          clearTimer() {
            // æ¸…ç†å®šæ—¶å™¨
            clearInterval(this.timer);
          },
          addKeyboardEvents() {
            // æ·»åŠ å…¨å±€é”®ç›˜æŒ‰ä¸‹äº‹ä»¶
            document.onkeydown = (event) => {
              console.log(event);
              switch (event.keyCode) {
                case 38:
                  this.changeMoveDirection(0);
                  break;
                case 39:
                  this.changeMoveDirection(1);
                  break;
                case 40:
                  this.changeMoveDirection(2);
                  break;
                case 37:
                  this.changeMoveDirection(3);
                  break;
              }
            };
          },
        },
        async mounted() {
          await this.initializationGrid(); // åˆå§‹åŒ–ç½‘æ ¼
          this.initializationSnake(); // åˆå§‹åŒ–è›‡
          this.initializationTimer(); // åˆå§‹åŒ–å®šæ—¶å™¨
          this.generateFood(); // ç”Ÿæˆé£Ÿç‰©
          this.addKeyboardEvents(); // æ·»åŠ é”®ç›˜æŒ‰ä¸‹äº‹ä»¶
        },
        destroyed() {
          this.clearTimer();
        },
        computed: {
          longitudinal() {
            // è·å–å®¹å™¨å®½é«˜æ¯”,è®¡ç®—çºµåæ ‡æ–¹æ ¼æ•°
            let boxWidth = this.$refs.container.clientWidth;
            let boxHeight = this.$refs.container.clientHeight;
            let longitudinal = parseInt(
              (boxHeight / boxWidth) * this.transverse
            );
            return longitudinal;
          },
        },
      });
    </script>
  </body>
</html>
